local M = {}

-- State management
M.current_interpreter = nil
M.project_root = nil

-- Find project root by walking up from current file
function M.find_project_root()
  local markers = { ".git", "pyproject.toml", "setup.py", "requirements.txt", ".nvim.lua" }
  local current_file = vim.fn.expand("%:p")

  -- Start from file's directory, walk up to root
  local path = vim.fn.fnamemodify(current_file, ":h")

  while path ~= "/" do
    for _, marker in ipairs(markers) do
      if vim.fn.isdirectory(path .. "/" .. marker) == 1 or vim.fn.filereadable(path .. "/" .. marker) == 1 then
        M.project_root = path
        return path
      end
    end
    path = vim.fn.fnamemodify(path, ":h")
  end

  -- Fallback to current working directory
  M.project_root = vim.fn.getcwd()
  return M.project_root
end

-- Detect available Python interpreters
function M.detect_interpreters()
  local interpreters = {}
  local seen = {} -- Deduplicate by resolved path

  local function add_interpreter(path, label, priority)
    if vim.fn.executable(path) == 1 then
      local resolved = vim.fn.resolve(path)
      if not seen[resolved] then
        seen[resolved] = true
        -- Get version info
        local version_output = vim.fn.system(path .. " --version 2>&1")
        local version = version_output:match("Python (%d+%.%d+%.%d+)")

        table.insert(interpreters, {
          path = resolved,
          label = string.format("%s (%s)", label, version or "unknown"),
          priority = priority,
        })
      end
    end
  end

  local root = M.find_project_root()

  -- 1. Project virtual environments (priority 100)
  add_interpreter(root .. "/.venv/bin/python", "Project .venv", 100)
  add_interpreter(root .. "/venv/bin/python", "Project venv", 90)
  add_interpreter(root .. "/.virtualenv/bin/python", "Project .virtualenv", 85)

  -- 2. pyenv versions (priority 50-70)
  local pyenv_root = os.getenv("PYENV_ROOT") or (os.getenv("HOME") .. "/.pyenv")
  local versions_dir = pyenv_root .. "/versions"

  if vim.fn.isdirectory(versions_dir) == 1 then
    -- Scan for pyenv versions
    local handle = io.popen("ls -1 " .. versions_dir .. " 2>/dev/null")
    if handle then
      for version in handle:lines() do
        local python_path = versions_dir .. "/" .. version .. "/bin/python"
        -- Check if it's an environment (has envs subdirectory) or base version
        local is_env = vim.fn.isdirectory(versions_dir .. "/" .. version .. "/envs") == 0
        local priority = is_env and 70 or 60
        add_interpreter(python_path, "pyenv: " .. version, priority)
      end
      handle:close()
    end
  end

  -- 3. System Python (priority 10-20)
  add_interpreter(vim.fn.exepath("python3"), "System python3", 20)
  add_interpreter(vim.fn.exepath("python"), "System python", 15)
  add_interpreter("/usr/bin/python3", "System /usr/bin/python3", 10)
  add_interpreter("/usr/local/bin/python3", "Homebrew python3", 12)

  -- Sort by priority (descending)
  table.sort(interpreters, function(a, b)
    return a.priority > b.priority
  end)

  return interpreters
end

-- Present UI for interpreter selection
function M.select_interpreter()
  local interpreters = M.detect_interpreters()

  if #interpreters == 0 then
    vim.notify("No Python interpreters found", vim.log.levels.WARN)
    return
  end

  -- Format items for vim.ui.select
  local items = {}
  for _, interp in ipairs(interpreters) do
    table.insert(items, interp.label)
  end

  vim.ui.select(items, {
    prompt = "Select Python Interpreter:",
    format_item = function(item)
      return item
    end,
  }, function(choice, idx)
    if not choice then
      return -- User cancelled
    end

    local selected = interpreters[idx]
    M.current_interpreter = selected.path

    -- Apply to DAP and LSP
    M.apply_interpreter(selected.path)

    -- Persist to .nvim.lua
    M.persist_selection(selected.path)

    vim.notify("Python interpreter set to: " .. selected.path, vim.log.levels.INFO)
  end)
end

-- Persist selected interpreter to .nvim.lua
function M.persist_selection(path)
  local root = M.find_project_root()
  local config_path = root .. "/.nvim.lua"

  local content = string.format("-- Auto-generated by :SelectPythonInterpreter\nvim.g.python_interpreter_path = %q\n", path)

  local file = io.open(config_path, "w")
  if file then
    file:write(content)
    file:close()
    vim.notify("Saved to " .. config_path, vim.log.levels.INFO)
  else
    vim.notify("Failed to write " .. config_path, vim.log.levels.ERROR)
  end
end

-- Load persisted interpreter from .nvim.lua
function M.load_persisted()
  local root = M.find_project_root()
  local config_path = root .. "/.nvim.lua"

  if vim.fn.filereadable(config_path) == 1 then
    local ok, err = pcall(dofile, config_path)

    if not ok then
      vim.notify("Error loading " .. config_path .. ": " .. err, vim.log.levels.ERROR)
      return
    end

    local python_path = vim.g.python_interpreter_path

    if python_path and vim.fn.executable(python_path) == 1 then
      M.current_interpreter = python_path
      M.apply_interpreter(python_path)
      vim.notify("Loaded Python interpreter: " .. python_path, vim.log.levels.INFO)
    elseif python_path then
      vim.notify("Persisted Python interpreter not found: " .. python_path, vim.log.levels.WARN)
    end
  end
end

-- Update DAP Python configuration
function M.update_dap(path)
  local ok, dap_python = pcall(require, "dap-python")
  if ok then
    dap_python.setup(path)
    vim.notify("DAP updated to use: " .. path, vim.log.levels.DEBUG)
  else
    vim.notify("dap-python not available", vim.log.levels.WARN)
  end
end

-- Update LSP basedpyright configuration
function M.update_lsp(path)
  -- Update the config
  vim.lsp.config("basedpyright", {
    on_attach = function(client, bufnr)
      client.server_capabilities.semanticTokensProvider = nil
    end,
    settings = {
      python = {
        pythonPath = path,
      },
    },
  })

  -- Restart clients for Python buffers
  local clients = vim.lsp.get_clients({ name = "basedpyright" })

  for _, client in ipairs(clients) do
    local bufs = vim.lsp.get_buffers_by_client_id(client.id)

    -- Stop client
    client.stop()

    -- Re-enable LSP for those buffers
    vim.schedule(function()
      for _, bufnr in ipairs(bufs) do
        if vim.api.nvim_buf_is_valid(bufnr) then
          vim.lsp.enable("basedpyright")
        end
      end
    end)
  end

  vim.notify("LSP updated to use: " .. path, vim.log.levels.DEBUG)
end

-- Apply interpreter to both DAP and LSP
function M.apply_interpreter(path)
  vim.g.python_interpreter_path = path
  M.current_interpreter = path

  M.update_dap(path)
  M.update_lsp(path)
end

return M
